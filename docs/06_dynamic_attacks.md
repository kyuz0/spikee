# Writing Dynamic Attack Scripts

Dynamic Attacks are Python scripts that apply **iterative, real-time transformations** to a payload during `spikee test`. They are the ideal tool for discovering novel bypasses when your initial, pre-defined prompts fail.

Sample dynamic attacks can be found within the `workspace/attacks/` directory, created by running `spikee init`. Further information about built-in dynamic attacks and usage examples can be found in **[Built-in targets, attacks and judges](04_builtin_targets_attacks_and_judges.md)**.

### Dynamic Attacks vs. Plugins: What's the Difference?

Both Dynamic Attacks and Plugins can generate variations of a payload, but they serve different purposes in the testing workflow:

*   **Dynamic Attacks (Real-Time Transformation):**
    *   **When they run:** During `spikee test`, but *only if* the initial, standard prompt fails.
    *   **What they do:** Generate and test variations one by one in real-time. The attack stops as soon as a variation succeeds.
    *   **Result:** Only the first successful variation (or the final failed attempt) is logged. This is useful for efficiently finding *any* successful bypass, potentially with adaptive logic that learns from previous failed attempts.

*   **Plugins (Pre-Test Transformation):**
    *   **When they run:** During `spikee generate`.
    *   **What they do:** Create multiple variations of a payload. Each variation is saved as a **separate, independent entry** in the final dataset file.
    *   **Result:** When you run `spikee test`, every single variation generated by the plugin is tested against the target. This is useful for systematically evaluating a target's resilience to a known set of transformations.

In short, use **Dynamic Attacks** to find a single successful bypass with adaptive, real-time logic. Use **Plugins** to build a comprehensive dataset of known transformations.

## Attack Structure

Every attack is a Python module located in the `attacks/` directory of your workspace. Spikee identifies attacks by their filename.

### Attack Template

```python
from spikee.templates.attack import Attack
from typing import List

class SampleAttack(Attack):
    OPTIONS_MAP = {
        "strategy": ["random", "aggressive", "stealth"],
    }

    DEFAULT_OPTIONS = {
        "strategy": "random",
    }

    def get_available_option_values(self) -> List[str]:
        """Returns a list of supported option values, first is default. None if no options."""
        options = [f"{key}={entry}" for key, entry in self.DEFAULT_OPTIONS]
        options.extend(
            [
                f"{key}={value}"
                for key, values in self.OPTIONS_MAP.items()
                for value in values
                if value != self.DEFAULT_OPTIONS[key]
            ]
        )
        return options

    def attack(
        self,
        entry,
        target_module,
        call_judge,
        max_iterations,
        attempts_bar=None,
        bar_lock=None,
        attack_option=None,
    ) -> Tuple[int, bool, str, str]:
        """
        Executes a dynamic attack on the given entry.

        Args:
            entry (dict): The dataset entry. Expected keys: "text", optionally "payload" and "exclude_from_transformations_regex".
            target_module (module): The target module (must implement process_input(input_text, system_message)).
            call_judge (function): A function that accepts (entry, llm_response) and returns True if the attack is successful.
            max_iterations (int): The maximum number of attack iterations to try.
            attempts_bar (tqdm, optional): A progress bar to update for each iteration.
            attack_option (str, optional): Configuration option like "strategy=aggressive".

        Returns:
            tuple: (iterations_attempted, success_flag, modified_input, last_response)
        """
        # Parse attack option
        attack_option = attack_option.split(";") if attack_option else []
        options = {}

        for option in attack_option:
            key, value = option.split("=", 1)
            
            if key in self.OPTIONS_MAP:
                if value not in self.OPTIONS_MAP[key]:
                    valid = ", ".join(self.OPTIONS_MAP[key])
                    raise ValueError(f"Unknown value '{value}' for option '{key}'. Valid values: {valid}")
            else:
                raise ValueError(f"Unknown attack option '{key}'.")

            options[key] = value

        # Your implementation here...

```

## The `attack` Function
This is the core of every dynamic attack script. It contains the logic for generating and testing payload variations until a success is found or the iteration limit is reached.

### Parameters

*   `entry: Dict[str, Any]`: 
    The dictionary for the original dataset entry that failed the initial test. You can access all its fields, such as `text`, `payload`, and `system_message`.

*   `target_module: Any`: 
    A **wrapped instance** of the target module. When you call `target_module.process_input()`, it automatically handles the retries and throttling defined in your `spikee test` command. You do not need to implement this logic yourself.

*   `call_judge: callable`: 
    A function that lets you evaluate if a response is successful. Call it with `call_judge(entry, response)` to get a `True` or `False` result.

*   `max_iterations: int`: 
    The maximum number of iterations your attack loop can run, as specified by `--attack-iterations`. Your loop **must** respect this limit.

*   `attempts_bar` and `bar_lock`: 
    `tqdm` progress bar objects for updating the UI. For each attempt inside your loop, call `with bar_lock: attempts_bar.update(1)`.

*   `attack_option: Optional[str]`: 
    A single string passed from the command line via `--attack-options` (e.g., `"mode=aggressive"`).

### Return Value

The `attack` function must return a tuple containing four elements:
1.  `int`: The total number of iterations that were attempted.
2.  `bool`: The final success flag (`True` if any iteration succeeded).
3.  `str`: The payload of the **last** attempted iteration.
4.  `str`: The response from the **last** attempted iteration.

## Implementation Guidelines

1.  **Modify the Payload**: It is best practice to modify the `entry['payload']` and substitute it back into `entry['text']`. This focuses the attack on the malicious part while preserving the surrounding document structure.
2.  **Respect `max_iterations`**: Your main loop must not exceed this value.
3.  **Update Progress Bar**: Call `attempts_bar.update(1)` inside the `bar_lock` for every iteration to keep the UI in sync.
4.  **Handle Early Exit**: If an attack succeeds, break the loop. Before returning, you should adjust the progress bar's total to reflect the skipped iterations. This keeps the ETA accurate.
5.  **Be Stateless**: An attack function should not carry state between different dataset entries. All necessary information should come from the `entry` dictionary.

## Multi-Turn Dynamic Attacks
Spikee v5.5 introduced support for multi-turn attacks, which enabled dynamic attacks to perform assess conversational LLM applications against multi-turn prompt injection attacks. 

See `multi_turn` and `crescendo` attack scripts for examples of multi-turn dynamic attacks.

### Multi-Turn Attack Template
```python
import uuid

from spikee.templates.attack import Attack
from spikee.utilities.enums import Turn

class SampleMultiTurnAttack(Attack):
    def __init__(self):
        """Define multi-turn capabilities for attack."""
        # turn_type defines an attack's multi-turn capability, either Turn.SINGLE (Default) or Turn.MULTI
        super().__init__(turn_type=Turn.MULTI)
    
    def get_available_option_values(self) -> str:
        return None

    def attack(
        self,
        entry: dict,
        target_module: object,
        call_judge: callable,
        max_iterations: int,
        attempts_bar=None,
        bar_lock=None,
        attack_option: str = None,
    ) -> Tuple[int, bool, str, str]:
        """
        Executes a dynamic multi-turn attack on a given entry.

        Args:
            entry (dict): The dataset entry. Expected keys: "text", optionally "payload" and "exclude_from_transformations_regex".
            target_module (module): The target module (must implement process_input(input_text, system_message)).
            call_judge (function): A function that accepts (entry, llm_response) and returns True if the attack is successful.
            max_iterations (int): The maximum number of attack iterations to try.
            attempts_bar (tqdm, optional): A progress bar to update for each iteration.
            attack_option (str, optional): Configuration option like "strategy=aggressive".

        Returns:
            tuple: (iterations_used:int, success:bool, {"objective": str, "conversation": List[Dict]}, last_response:str)
        """

        session_id = str(uuid.uuid4()) # Unique session ID for multi-turn context
        conversation = [] # To store the conversation history

        
        loop:
            # Your implementation here...
            conversation.append({"role": "user", "content": message})
            conversation.append({"role": "assistant", "content": response})

        success = call_judge(entry, response)

        return len(entry["text"]), success, {"conversation": conversation}, response

        

```