# Creating Custom Targets

A Target is a Python script that acts as a bridge between Spikee and the system you want to test. While you can use targets to interact directly with an LLM's completion endpoint, their primary power lies in testing **LLM applications**.

You need a custom target when you want to:
*   Test a complete application workflow (e.g., submitting a form, sending an email).
*   Interact with a proprietary API that uses an LLM in its backend.
*   Connect to a new or unsupported LLM provider.
*   Evaluate a specific guardrail system in isolation.

This guide covers how to build a custom target for any of these scenarios. Sample targets can be found within the `workspace/targets/` directory, created by running `spikee init`. Further information about built-in targets and usage examples can be found in **[Built-in targets, attacks and judges](04_builtin_targets_attacks_and_judges.md)**.

## Target Structure
Every target is a Python module located in the `targets/` directory of your workspace. Spikee identifies targets by their filename.

### Target Template
```python
from spikee.templates.target import Target
from typing import Optional, Dict, List

class SampleTarget(Target):
    def get_available_option_values(self) -> List[str]:
        """Returns a list of supported option values, first is default. None if no options."""
        return None

    def process_input(
        self,
        input_text: str,
        system_message: Optional[str] = None,
        target_options: Optional[str] = None,
    ) -> str:
        """Sends prompts to the defined target

        Args:
            input_text (str): User Prompt
            system_message (Optional[str], optional): System Prompt. Defaults to None.
            target_options (Optional[str], optional): Target options. Defaults to None.

        Returns:
            str | bool: Response from the target (text response | guardrail result)
            throws tester.GuardrailTrigger: Indicates guardrail was triggered
            throws Exception: Raises exception on failure
        """
        # Your implementation here...
```

### The `process_input` Function
This is the core function that Spikee calls for every test case - it receives a dataset entry and returns the target's response.

#### Parameters
*   `input_text: str`: 
    The user prompt / dataset entry generated by Spikee. When testing an application, this is typically the data you are submitting (e.g., the body of an email, a user comment, a document for summarization).

*   `system_message: Optional[str]`: 
    The system prompt, if specified in the dataset. **When testing an application, you will likely ignore this parameter**, as you typically cannot control the application's internal system prompt. It is mainly used when testing a standalone LLM.

*   `target_options: Optional[str]`: 
    A string passed from the command line via `--target-options`.


#### Return Values
The `process_input` function's return type depends on what you are testing.

*   **For LLM Applications or Models**: Return the final text response as a string.
*   **For Guardrail Systems**: Return a boolean indicating if the payload was allowed.
    *   `True` signifies the guardrail was **bypassed** (an attack success). 
    *   `False` signifies the payload was **blocked** (an attack failure). This is essential for calculating performance metrics.

## Supporting Target Options
To make your target more flexible, you can advertise its supported `target_options` by implementing the `get_available_option_values` function. By default, it should return `None`, indicating no options are supported.

```python
# Basic Implementation
from typing import List

def get_available_option_values(self) -> List[str]:
    return ["default_option", "additional_option1", "additional_option2"]
```

```python
# Mapped Implementation
from typing import Optional, Dict, List

class ExampleMappedImplementation(Target):
    _OPTIONS_MAP: Dict[str, str] = {
        "example1": "https://reversec.com/api/example1",
        "example2": "https://reversec.com/api/example2",
    }
    _DEFAULT_KEY = "example1"

    def get_available_option_values(self) -> List[str]:
        """Returns a list of supported option values, first is default. None if no options."""
        options = [self._DEFAULT_KEY]
        options.extend([key for key in self._OPTIONS_MAP if key != self._DEFAULT_KEY])
        return options

    def process_input(
        self,
        input_text: str,
        system_message: Optional[str] = None,
        target_options: Optional[str] = None,
    ) -> str:
        # Option Validation
        key = target_options if target_options is not None else self._DEFAULT_KEY

        if key not in self._OPTIONS_MAP:
            valid = ", ".join(self.get_available_option_values())
            raise ValueError(f"Unknown option value '{key}'. Valid options: {valid}")

        option = self._OPTIONS_MAP[key]

        # Your implementation here...
```
When this function is present, `spikee list targets` will display the available options, making your target easier to use.

## Error Handling

*   **Invalid Options:** If your target uses `target_options`, validate the input and **raise a `ValueError`** on invalid values to prevent misconfigured tests.
*   **API Calls:** Wrap all external API calls in a `try...except` block. If an exception occurs, log it and **re-raise the exception**. This allows Spikee's main testing loop to catch the error and apply its retry logic (`--max-retries`).
*  **Guardrail Triggers:** If testing a guardrail system and the guardrail is triggered, **raise a `GuardrailTrigger` exception**. This informs Spikee that the payload was blocked, allowing it to log the result correctly.

```python
# Guardrail Trigger Example
from spikee.tester.guardrail_trigger import GuardrailTrigger
import requests

try:
    # Example external API call
    response = requests.get(
        "https://reversec.com/api/example",
        data=input_text
    )
    response.raise_for_status()
    return response.text

except requests.exceptions.RequestException as e
    if response.status_code == 400:  # Guardrail Triggered - HTTP Status code will vary by provider/application
        raise GuardrailTrigger(f"Guardrail was triggered by the target: {e}")

    else:
        print(f"Error during HTTP request: {e}")
        raise

```

## Multi-Turn Dynamic Targets
Spikee supports multi-turn attacks, using compatible attack and target scripts, which enable Spikee to assess conversational LLM applications against multi-turn prompt injection attacks.

As part of this the `MultiTarget` and `SimpleMultiTarget` parent classes have been implemented, which includes built-in support for managing conversation ID and history storage in a multiprocessing safe way. 

**Common Concepts Explained:**
* Spikee Session ID: This is a UUID generated by a Spikee attack script to uniquely identify a multi-turn attack entry.
* Target/Application Session ID: This is the identifier used by the target application to track the chat session. Its format (e.g., UUID, integer, string) is determined by the specific target implementation.

**`MultiTarget` Functions Explained:**
* `_get_target_data(identifier)`: Retrieves stored data for a given ID.
* `_update_target_data(identifier, data)`: Updates stored data for a given ID.

(NB, Please ensure that you call `_update_target_data` after modifying any retrieved data to ensure changes are saved.)

**`SimpleMultiTarget` Functions Explained:**
`SimpleMultiTarget` builds on `MultiTarget` by providing simplified conversation management and ID mapping for common use-cases..

* `_get_conversation_data(session_id)`: Retrieves the conversation data for a given session ID.
* `_update_conversation_data(session_id, conversation_data)`: Updates the conversation data for a given session ID.
* `_append_conversation_data(session_id, role, content)`: Appends a message to the conversation data for a given session ID.
* `_get_id_map(spikee_session_id)`: Obtains the mapping of Spikee session IDs to target session IDs.
* `_update_id_map(spikee_session_id, associated_ids)`: Updates the mapping of Spikee session IDs to target session IDs.

### Backtracking Support
Backtracking refers to the ability to "undo" the last turn in a conversation. This is crucial for certain multi-turn attacks (e.g., Crescendo) which rely on removing failed attempts (refusals) from the conversation history to prevent the LLM from entering a defensive state.

**Configuration:**
To assert that your target supports backtracking, set `backtrack=True` in the `__init__` method:
```python
super().__init__(turn_types=[Turn.MULTI], backtrack=True)
```

**Implementation:**
When `process_input` is called with `backtrack=True`, your target **must** remove the last pair of user and assistant messages from its stored history before processing the new `input_text`.

**Fallback Behavior:**
If a target does not support backtracking (`backtrack=False`), attacks like Crescendo will automatically abort the current attempt upon refusal and restart with a fresh session ID, ensuring a clean state for the next attempt.

### Example Function Implementations
```python

# Generic Data Operations
# This example shows the target dict being used to store session data.

target_data = self._get_target_data(spikee_session_id)

target_data.append({"role": "user", "content": "How does Spikee work?"})

self._update_target_data(spikee_session_id, target_data) # Please ensure to call update after modifying data, to save changes.


# Simplified Conversation Operations
# This example shows how to use the simplified conversation functions to manage chat history.
session_id = uuid.uuid4()
self._update_conversation_data(session_id, [{"role": "user", "content": "Hello!"}]) # Create a new conversation for the session ID
self._append_conversation_data(session_id, "assistant", "Hi there! How can I help you today?") # Append a message to the conversation
self._get_conversation_data(session_id)  # Retrieve the conversation data for the session ID


# Simplified ID Mapping Operations
spikee_session_id = uuid.uuid4()
self._update_id_map(spikee_session_id, ["application-id-20"])  # Map Spikee session ID to target/application session ID
associated_ids = self._get_id_map(spikee_session_id)  # Retrieve the mapped target/application session IDs
```



See `workspace/targets/test_chatbot.py` for an example implementation of a `MultiTarget` target that manually manages session state and history.
See `workspace/targets/simple_test_chatbot.py` for an example implementation of a `SimpleMultiTarget` that simplifies this process.

### Multi-Turn Target Template
```python
import uuid

from spikee.templates.multi_target import MultiTarget
from spikee.utilities.enums import Turn


class SampleMultiTurnTarget(MultiTarget):
    def __init__(self):
        super().__init__(
            # Specify that this target supports both single-turn and multi-turn interactions (Target Default is SINGLE only, MultiTarget default is MULTI only)
            turn_types=[Turn.SINGLE, Turn.MULTI],  

            # Does the target + target application support backtracking (e.g., editing previous messages in the conversation)
            backtrack=True 
        )

    def get_available_option_values(self) -> List[str]:
        return None

    def process_input(
        self,
        input_text: str,
        system_message: Optional[str] = None,
        target_options: Optional[str] = None,
        spikee_session_id: Optional[str] = None,
        backtrack: Optional[bool] = False,
    ) -> str:
        """
        Sends prompts to the defined target

        Args:
            input_text (str): User Prompt
            system_message (Optional[str], optional): System Prompt. Defaults to None.
            target_options (Optional[str], optional): Target options. Defaults to None.
            spikee_session_id (Optional[str], optional): Unique Spikee session ID for multi-turn context. Defaults to None.
            backtrack (Optional[bool], optional): Indicates if backtracking is enabled for this interaction. Defaults to False.

        Returns:
            str: Response from the target application
        """

        self._get_target_data(spikee_session_id)

        # Your implementation here...

        self._update_target_data(spikee_session_id, target_data)
        return response_text
```

### Simplified Multi-Turn Target Template
```python
import uuid

from spikee.templates.simple_multi_target import SimpleMultiTarget
from spikee.utilities.enums import Turn


class SampleSimpleeMultiTurnTarget(SimpleMultiTarget):
    def __init__(self):
        super().__init__(
            turn_types=[Turn.SINGLE, Turn.MULTI],  
            backtrack=True 
        )

    def get_available_option_values(self) -> List[str]:
        return None

    def process_input(
        self,
        input_text: str,
        system_message: Optional[str] = None,
        target_options: Optional[str] = None,
        spikee_session_id: Optional[str] = None,
        backtrack: Optional[bool] = False,
    ) -> str:
        conversation_data = self._get_conversation_data(spikee_session_id)

        # Your implementation here...

        self._append_conversation_data(spikee_session_id, role="user", content=input_text)
        self._append_conversation_data(spikee_session_id, role="assistant", content=response_text)
        return response_text
```