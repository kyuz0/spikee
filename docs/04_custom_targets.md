# Creating Custom Targets

A Target is a Python script that acts as a bridge between Spikee and the system you want to test. While you can use targets to interact directly with an LLM's completion endpoint, their primary power lies in testing **LLM applications**.

You need a custom target when you want to:
*   Test a complete application workflow (e.g., submitting a form, sending an email).
*   Interact with a proprietary API that uses an LLM in its backend.
*   Connect to a new or unsupported LLM provider.
*   Evaluate a specific guardrail system in isolation.

This guide covers how to build a custom target for any of these scenarios. Sample targets can be found within the `workspace/targets/` directory, created by running `spikee init`. Further information about built-in targets and usage examples can be found in **[Built-in targets, attacks and judges](04_builtin_targets_attacks_and_judges.md)**.

## Target Structure
Every target is a Python module located in the `targets/` directory of your workspace. Spikee identifies targets by their filename.

### Target Template
```python
from spikee.templates.target import Target
from typing import Optional, Dict, List

class SampleTarget(Target):
    def get_available_option_values(self) -> List[str]:
        """Returns a list of supported option values, first is default. None if no options."""
        return None

    def process_input(
        self,
        input_text: str,
        system_message: Optional[str] = None,
        target_options: Optional[str] = None,
    ) -> str:
        """Sends prompts to the defined target

        Args:
            input_text (str): User Prompt
            system_message (Optional[str], optional): System Prompt. Defaults to None.
            target_options (Optional[str], optional): Target options. Defaults to None.

        Returns:
            str | bool: Response from the target (text response | guardrail result)
            throws tester.GuardrailTrigger: Indicates guardrail was triggered
            throws Exception: Raises exception on failure
        """
        # Your implementation here...
```

### The `process_input` Function
This is the core function that Spikee calls for every test case - it receives a dataset entry and returns the target's response.

#### Parameters
*   `input_text: str`: 
    The user prompt / dataset entry generated by Spikee. When testing an application, this is typically the data you are submitting (e.g., the body of an email, a user comment, a document for summarization).

*   `system_message: Optional[str]`: 
    The system prompt, if specified in the dataset. **When testing an application, you will likely ignore this parameter**, as you typically cannot control the application's internal system prompt. It is mainly used when testing a standalone LLM.

*   `target_options: Optional[str]`: 
    A string passed from the command line via `--target-options`.


#### Return Values
The `process_input` function's return type depends on what you are testing.

*   **For LLM Applications or Models**: Return the final text response as a string.
*   **For Guardrail Systems**: Return a boolean indicating if the payload was allowed.
    *   `True` signifies the guardrail was **bypassed** (an attack success). 
    *   `False` signifies the payload was **blocked** (an attack failure). This is essential for calculating performance metrics.

## Supporting Target Options
To make your target more flexible, you can advertise its supported `target_options` by implementing the `get_available_option_values` function. By default, it should return `None`, indicating no options are supported.

```python
# Basic Implementation
from typing import List

def get_available_option_values(self) -> List[str]:
    return ["default_option", "additional_option1", "additional_option2"]
```

```python
# Mapped Implementation
from typing import Optional, Dict, List

class ExampleMappedImplementation(Target):
    _OPTIONS_MAP: Dict[str, str] = {
        "example1": "https://reversec.com/api/example1",
        "example2": "https://reversec.com/api/example2",
    }
    _DEFAULT_KEY = "example1"

    def get_available_option_values(self) -> List[str]:
        """Returns a list of supported option values, first is default. None if no options."""
        options = [self._DEFAULT_KEY]
        options.extend([key for key in self._OPTIONS_MAP if key != self._DEFAULT_KEY])
        return options

    def process_input(
        self,
        input_text: str,
        system_message: Optional[str] = None,
        target_options: Optional[str] = None,
    ) -> str:
        # Option Validation
        key = target_options if target_options is not None else self._DEFAULT_KEY

        if key not in self._OPTIONS_MAP:
            valid = ", ".join(self.get_available_option_values())
            raise ValueError(f"Unknown option value '{key}'. Valid options: {valid}")

        option = self._OPTIONS_MAP[key]

        # Your implementation here...
```
When this function is present, `spikee list targets` will display the available options, making your target easier to use.

## Error Handling

*   **Invalid Options:** If your target uses `target_options`, validate the input and **raise a `ValueError`** on invalid values to prevent misconfigured tests.
*   **API Calls:** Wrap all external API calls in a `try...except` block. If an exception occurs, log it and **re-raise the exception**. This allows Spikee's main testing loop to catch the error and apply its retry logic (`--max-retries`).
*  **Guardrail Triggers:** If testing a guardrail system and the guardrail is triggered, **raise a `GuardrailTrigger` exception**. This informs Spikee that the payload was blocked, allowing it to log the result correctly.

```python
# Guardrail Trigger Example
from spikee.tester.guardrail_trigger import GuardrailTrigger
import requests

try:
    # Example external API call
    response = requests.get(
        "https://reversec.com/api/example",
        data=input_text
    )
    response.raise_for_status()
    return response.text

except requests.exceptions.RequestException as e
    if response.status_code == 400:  # Guardrail Triggered - HTTP Status code will vary by provider/application
        raise GuardrailTrigger(f"Guardrail was triggered by the target: {e}")

    else:
        print(f"Error during HTTP request: {e}")
        raise

```